<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on Wangyujie</title>
    <link>https://wangyujie1207.github.io/tags/java/</link>
    <description>Recent content in java on Wangyujie</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 29 Oct 2019 13:53:28 +0800</lastBuildDate>
    
	<atom:link href="https://wangyujie1207.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Collection初步接触</title>
      <link>https://wangyujie1207.github.io/2019/collection%E5%88%9D%E6%AD%A5%E6%8E%A5%E8%A7%A6/</link>
      <pubDate>Tue, 29 Oct 2019 13:53:28 +0800</pubDate>
      
      <guid>https://wangyujie1207.github.io/2019/collection%E5%88%9D%E6%AD%A5%E6%8E%A5%E8%A7%A6/</guid>
      <description> Java集合的集成体系 Java的集合类主要由两个接口派生而出：Collection和Map,Collection和Map是Java集合框架的根接口。一张图看出Java collection的重要性
 Collection接口是Set,Queue,List的父接口。Collection接口中定义了多种方法可供其子类进行实现，以实现数据操作。  List list add时,容量看起来无限,实际内部进行了扩容,扩容大小为当前容量的一半
Set  不允许出现重复的元素 集合中的元素位置无顺序 有且只有一个值为null的元素  因为set是一个抽象的接口，所以不能直接实例化一个set对象。（Set s = new Set()是错误的）
Set接口的两大实现：HashSet、TreeSet
HashSet 是无序的，如果要保持顺序，可以使用LinkedHashSet.
HashMap和HashSet  HashSet  HashSet实现了Set接口，不允许集合中有重复的值  HashMap  HashMap实现了Map接口，Map接口对键值对进行映射。Map中不允许重复的键 Map接口的俩个基本实现：HashMap和TreeMap，TreeMap保存了对象的排列次序，而HashMap则不能。 HashMap允许键和值为null   Collection中常用的方法 Guava 集合工具类库
//添加方法： add(Object o) //添加指定元素 addAll(Collection c) //添加指定集合 //删除方法： remove(Object o) //删除指定元素 removeAll(Collection c) //输出两个集合的交集 retainAll(Collection c) //保留两个集合的交集 clear() //清空集合 //查询方法： size() //集合中的有效元素个数 toArray() //将集合中的元素转换成Object类型数组 //判断方法： isEmpty() //判断是否为空 equals(Object o) //判断是否与指定元素相同 contains(Object o) //判断是否包含指定元素 containsAll(Collection c) //判断是否包含指定集合  ArrayList中特有的方法 ensureCapacity(int minCapactiy) //判断当前数组中的元素个数是否大于指定的minCapacity trimToSize() //修改数组容量为当前数组有效元素个数  LinkedList中特有的方法 //查询方法： getFirst() //获取集合中的第一个元素 getLast() //获取集合中的最后一个元素 //添加方法： addFirst(Object o) //在集合的第一个位置添加指定元素 addLast(Object o) //在集合的最后一个位置添加指定元素 //删除方法： removeFirst() //删除集合中的第一个元素 removeLast() //删除集合中的最后一个元素  </description>
    </item>
    
    <item>
      <title>Maven与Java包的初级接触</title>
      <link>https://wangyujie1207.github.io/2019/maven%E4%B8%8Ejava%E5%8C%85%E7%9A%84%E5%88%9D%E7%BA%A7%E6%8E%A5%E8%A7%A6/</link>
      <pubDate>Mon, 28 Oct 2019 13:46:32 +0800</pubDate>
      
      <guid>https://wangyujie1207.github.io/2019/maven%E4%B8%8Ejava%E5%8C%85%E7%9A%84%E5%88%9D%E7%BA%A7%E6%8E%A5%E8%A7%A6/</guid>
      <description> 什么是maven Maven是一个采用纯Java编写的开源项目管理工具, Maven采用了一种被称之为 Project Object Model (POM)概念来管理项目，所有的项目配置信息都被定 义在一个叫做POM.xml的文件中..   Maven主要服务于基于Java平台的项目构建、依赖管理和项目信息管理&amp;hellip;  仓库 本地仓库  Maven会把我们项目所构建出来的jar包等等资源存放在本地仓库中。当我们需要jar包的时候，Maven第一时间也是去本地仓库中寻找jar包
中心仓库 ** 当Maven在本地仓库和私服找不到我们需要的jar包的时候，就去中心仓库中帮我们下载对应的jar包**。那Maven怎么知道去哪里下载呢？？其实Maven已经配置好的了 apache-maven-3.2.1\lib\maven-model-builder-3.2.1\org\apache\maven\model下的POM.xml文件中已经配置好了
  maven坐标 坐标的组成： groupId + artifactId+ version * groupId：组id ,机构名，公司名：好比公司的id，或者是公司包名 alibaba ——-》高德--》5.01版本 * artifactId：构建物id ，产品名或者产品的id * version ：版本号  jar包组成： artifactId-version.jar scope应用范围有test、compile等等，默认是compile，那么test和compile有什么区别呢？
 间接依赖问题 ：依赖的jar包必须是 compile 范围，假如是test范围，则发布的jar包不会包含test范围依赖的jar包，和依赖关系  &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;  Java的包管理机制 ##. 什么是包 * JVM的工作被设计得相当简单：
1. 执行一个类的字节码 2. 假如这个过程中碰到了新的类，加载他   那么去哪里加载他呢？  类路径（Classpath）  什么是类路径：-classpath/-cp 类的全限定类名（目录层级）唯一确定了一个类 包就是把许多类放在一起打的压缩包  Classpath hell  传递性依赖是指你依赖的类还依赖了别的类 全限定类名是类的唯一标识 当多个同名类同时出现在Classpath中，就是噩梦的开始  什么是包管理  你要使用一些第三方类，就要告诉JVM从哪里找 包管理的实质就是告诉JVM如何找到所需的第三方库以及成功地解决其中地冲突问题  Maven——划时代的包管理工具  约定优于配置（Convention over configuration） 必须强调，Maven远远不止是包管理工具 Maven的包按照约定为所有的包编号，方便检索，groupId/artifactId/version 依赖冲突的解决原则：最近的胜出 当你看到如下异常的时候：  * AbstractMethodError * NoClassDefFoundError * ClassNotFoundException * LinkageError   一般就是包冲突了，解决方法：  * 单独声明需要引用的特定包 * 排除掉冲突的包  </description>
    </item>
    
  </channel>
</rss>